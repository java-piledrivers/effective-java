# 15. ****클래스와 멤버의 접근 권한을 최소화하라****

어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 바로 클래스 내부 데이터와 내부 구현 정보
를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐다. 

### **정보 은닉의 장점**

1. `시스템 개발 속도를 높인다.` 여러 컴포넌트를 병렬로 개발 가능하게 만듬
2. `시스템 관리 비용을 낮춘다.` 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적게 만듬
3. 정보 은닉 자체가 성능을 높여 주지는 않지만, `성능 최적화에 도움`을 준다.
4. `소프트웨어 재사용성을 높인다.` 외부에 거의 의존하지 않고 독자적으로 동작할 수 있는 컴포넌트라면 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크기 때문이다.
5. `큰 시스템을 제작하는 난이도를 낮춰준다.`

### 기본원칙

→ **모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.**

공개 API를 세심히 설계한 후, 그 외의 모든 멤버는 private으로 만들자. 그런 다음 오직 다른 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 package-private으로 풀어주자.

### public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.

public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.

심지어 필드가 final이면서 불변 객체를 참조 하더라도 문제는 여전히 남는다. 내부 구현을 바꾸고 싶어도 그 public 필드를 없애는 방식으로는 리팩터링 할 수 없게 된다.

예외적으로 상수는 public static final 붙일 수 있다. 이러한 상수는 반드시 기본타입값이나 불변객체를 참조하여야 한다.

주의 ) 길이가 0이 아닌 배열은 모두 변경 가능하니 주의하자. 따라서 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안 된다. 이런 필드나 접근자를 제공한다면 클라이언트에서 그 배열의 내용을 수정할 수 있게 된다. 예컨대 다음 코드에는 보안 허점이 존재한다.

```java
// 보안 허점이 숨어 있다.
public static final Thing[] VALUES = { ... };
```

해결책1 ) 앞 코드의 public 배열을 private으로 만들고 public 불변 리스트를 추가하는 것이다.

```java
private static final Thing[] PRIVATE_VALUES = { ... };
public static final List<Thing> VALUES = 
	Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
```

해결책2) 두 번째는 배열을 private으로 만들고 그 복사본을 반환하는 public 메서드를 추가하는 방법이다(방어적 복사)

```java
private static final Thing[] PRIVATE_VALUES = { ... };
public static final Thing[] values)_ {
    return PRIVATE_VALUES.clone();
}
```

## 정리

`프로그램 요소의 접근성은 가능한 한 최소한으로 하라.`
꼭 필요한 것만 골라 최소한의 public API를 설계하자. 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개 되는 일이 없도록 해야 한다. public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다. public static final 필드가 참조하는 객체가 불변 인지 확인하라.
