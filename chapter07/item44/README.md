**java.util.function 패키지를 보면 다양한 인터페이스가 담겨 있다.** 

### **필요한 용도에 맞는 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하라.**

java.util.function 패키지에는 총 43개의 인터페이스가 담겨 있다. 

전부 기억하기는 어렵겠지만, 기본 인터페이스 6개만 기억하면 나머지를 충분히 유추해 낼 수 있다. 

| 인터페이스 | 함수 시그니처 | 예 | 세부 |
| --- | --- | --- | --- |
| UnaryOperator<T> | T apply(T t) | String::toLowerCase | 인수가 한개 |
| BinaryOperator<T> | T apply(T t1, T t2) | BigInteger::add | 인수가 2개  |
| Predicate<T> | boolean test(T t)  | Collection::isEmpty | 인수 하나를 받아 boolean을 반환하는 함수를 뜻한다. |
| Function<T> | R apply(T t)  | Arrays::asList | 인수와 반환 타입이 다른 함수를 뜻한다. |
| Supplier<T> | T get() | Instant::now | 인수를 받지 않고 값을 반환(혹은 제공)하는 함수를 뜻한다. |
| Consumer<T> | void accept(T t) | System.out::println | 인수를 하나 받고 반환값은 없는 (특히 인수를 소비하는)함수를 뜻한다. |

---

표준함수형 인터페이스 대부분은 기본 타입만 지원한다. 

### 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말자

- 동작은 하지만 “박싱된 기본 타입 대신 기본 타입을 사용하라” Item61.
    - why? 계산량이 많을 때는 성능이 처참히 느려질 수 있다.
        - 대부분의 상황에서는 직접 작성하는 것 보다 표준 함수형 인터페이스를 사용하는 편이 나음.
            - when ? 코드를 직접 작성해야 하는 때
                1. **표준 인터페이스 중에 용도에 맞는 게 없다면 직접 작성** 
                    
                    ex) 매개변수 3개를 받는 Predicate라든가 검사 예외를 던지는 경우가 있을 수 있다. 
                    
                2. **구조적으로 똑같은 표준 함수형 인터페이스라도 직접 작성해야만 하는 경우.** 
                    
                    ex) Comparator 
                    
                    : why? Comparator 함수형 인터페이스는 표준 함수형 인터페이스인 ToIntBiFunction 과 추상 메서드가 완벽히 같음에도 따로 만들었다.
                    
                    - 추상 메서드가 같음에도 직접 함수형 인터페이스를 통해 구현할 수 있고 이름을 줄 수 있기 때문이다.
                    - Comparator가 독자적인 인터페이스로 살아남아야 하는 이유 ?
                        - 첫 번째, API에서 굉장히 자주 사용된다.
                        - 두 번째, 구현하는 쪽에서 반드시 지켜야할 규약을 담고 있다.
                        - 세 번째, 비교자들을 변환하고 조합해주는 유용한 디폴트 메서드들을 듬뿍 담고 있다.
                    
                     
                    
                    **Comparator 특성 세가지** 
                    
                    - 자주 쓰이며, 이름 자체가 용도를 명확히 설명해준다.
                    - 반드시 따라야 하는 규약이 있다.
                    - 유용한 디폴트 메서드를 제공할 수 있다.
                    
                    위 중 하나를 만족한다면 전용 함수형 인터페이스를 구현해야 하는 건 아닌지 진중히 고민해야 한다. 
                    

---

### @FunctionalInterface

- 이 애너테이션을 사용하는 이유는 @Override와 유사하다.
- 프로그래머의 의도를 명시하는 것으로, 크게 세가지 목적이 있다.
    - 첫 번쨰, 해당 클래스의 코드나 설명 문서를 읽을 이에게 그 인터페이스가 람다용으로 설계된 것임을 알려준다.
    - 두 번째, 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일되게 해준다.
    - 세 번째, 그 결과 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막아준다.

> 직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용하자.
>
