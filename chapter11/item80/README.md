[item 80] 스레드보다는 실행자, 태스크, 스트림을 애용하라
===

책의 초판 아이템49에서 단순한 작업 큐를 선보였다.
- 클라이언트가 요청한 작업을 백그라운드 스레드에 위임해 비동기적으로 처리하는 내용.
- 작업 큐가 필요 없어지면 클라이언트는 큐에 중단 요청, 큐는 남아있는 작업을 마저 완료한 후 스스로 종료
- 간단한 예시용 코드지만 책의 한페이지를 가득 채웠다. 이제 이런거 안써도 된다.

## 실행자 프레임워크(Executor Framework)
- java.util.concurrent 패키지 등장. 실행자 프레임워크라고하는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다.

### 생성
```java
ExecutorService exec = Executors.newSingleThreadExecutor();
```

### 실행자에 실행할 테스크 넘기기
```java
exec.execute(runnable);
```

### 실행자 우아하게 종료
- 이 작업 실패시 VM 자체가 종료되지 않을 것이다.
```java
exec.shutdown();
```

### 실행자 서비스의 주요 기능
- 특정 테크스가 완료되기를 기다린다(코드 72-9에서 본 get 메서드).
- 태스크 모음 중 아무것 하나(invokeAny 메서드) 혹은 모든 태스크(invokeAll 메서드)가 완료되기를 기다린다.
- 실행자 서비스가 종료하기를 기다린다(awaitTermination 메서드).
- 완료된 태스크들의 결과를 차례로 받는다(ExecutorCompletionService 이용).
- 태스크를 특정 시간에 혹은 주기적으로 실행하게 한다(ScheduledThreadPoolExecutor 이용).

+ 큐를 둘 이상의 스레드가 처리하게 하고 싶다면 간단히 다른 정적 팩터리를 이용하여 다른 종류의 실행자 서비스(스레드 풀)를 생성하면 된다.
+ 스레드 풀의 스레드 개수는 고정할 수도 있고 필요에 따라 늘어나거나 줄어들게 설정할 수도 있다.
+ 필요한 실행자 대부분은 java.util.concurrent.Executors의 정적 팩터리를 이용해 생성 가능할 것이다.
+ 평범하지 않은 실행자를 원한다면 ThreadPoolExecutor 클래스를 직접 사용해도 된다.

### 실행자 서비스를 사용하기에 까다로운 어플리케이션
- 작은 프로그램 -> Executors.newCachedThreadPool (CachedThreadPool) 사용
  - 무거운 프로그램에 써서는 안된다.
  - 요청받은 태스크들이 큐에 쌓이지 않고 즉시 스레드에 위임되어 실행된다.
  - <u>가용한 스레드가 없다면 새로 하나를 생성한다.</u> 서버가 무겁다면 CPU 이용률이 급증, 새로운 태스크가 도착하면 다른 스레드를 계속 생성해서 악화시킨다.
- 무거운 프로덕션 서버에서는 스레드 개수를 고정한 Executors.newFixedThreadPool을 선택하거나 완전히 통제할 수 있는 ThreadPoolExecutor를 직접 사용하는 편이 훨씬 낫다.

### 작업 단위와 실행 메커니즘
작업 단위
- Runnable, Callable(Runnable과 유사하지만 값을 반환, 임의의 예외)

테스크를 수행하는 일반적인 메커니즘
- 실행자 서비스
    - 언제나 원하는 태스크 수행 정책을 선택할 수 있고, 생각이 바뀌면 언제든 변경할 수 있다.
    - 핵심은 실행자 프레임워크가 작업 수행을 담당해 준다는 것이다.

작업 큐를 손수 만드는 일은 삼가야하고, 스레드를 직접다루는 것도 일반적으로 삼가야 한다. 
스레드를 직접 다루면 Thread가 작업 단위와 수행 메커니즘 역할을 모두 수행하게 된다. 
반면, 실행자 프레임워크에서는 작업 단위와 실행 메커니즘이 분리된다.

### 포크-조인 태스크(ForkJoinTask)
- 자바 7이 되면서 실행자 프레임워크는 포크-조인 태스크를 지원하도록 확장
- ForkJoinTask의 인스턴스는 작은 하위 태스크로 나뉠 수 있고, 
ForkJoinPool을 구성하는 스레드들이 이 태스크들을 처리하며, 
일을 먼저 끝낸 스레드는 다른 스레드의 남은 태스크를 가져와 대신 처리할 수 있다.
- 모든 스레드가 바쁘게 움직여 CPU를 최대한 활용 -> 높은 처리량과 낮은 지연시간
- 직접 작성하고 튜닝하긴 ㅓㅇ려운 일이지만, 포크-조인 풀을 이용해 만든 병렬 스트림을 이용하면 적은 노력으로 그 이점을 얻을 수 있다.
